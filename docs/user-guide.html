<meta charset="utf-8" emacsmode="-*- markdown -*-">
<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/apidoc.css?">

**Snestistics User Guide**

Command Line Reference
======================
## Rom
Name | Short | Type | Description
:----|-------|:-----|:-----------
*romfile* | r | input file name | ROM file. Currently only LoROM ROMs are allowed.
*rom-header* | rh | enumeration | Specify header type of ROM.<br><br>**auto**: Size of ROM file % (32*1024) (default)<br>**none**: 0<br>**smc**: 512
*rom-size* | rs | integer | Size of ROM cartridge (without header). When a 0 if specified this is determined as ROM file size minus ROM header size.
*rom-mode* | rm | enumeration | Type of ROM.<br><br>**lorom**: LoROM (default)<br>**hirom**: HiROM

## Trace
Name | Short | Type | Description
:----|-------|:-----|:-----------
*tracefile* | t | input file name | Trace file from an emulation session. Multiple allowed for assembly source listing (but not trace log or rewind).
*regenerate* | rg | boolean | Regenerate emulation caches. Needs to be run if trace files has been updated.
*predict* | p | enumeration | Predict can add instructions that was not part of the trace by guessing.<br><br>**nothing**: No prediction<br>**functions**: Only predict within annotated functions (default)<br>**everything**: Predict as much as possible

## Assembly Listing
Name | Short | Type | Description
:----|-------|:-----|:-----------
*asmoutfile* | a | output file name | Generated assembly listing.
*asmheaderfile* | ah | input file name | Content of this file will be pasted in the Header section of the generated assembly source listing.
*asm-pc* |  | boolean | Print program counter in assembly source listing.
*asm-bytes* |  | boolean | Print opcode bytes in assembly source listing.
*asm-lower-opcode* |  | boolean | Print lower-case opcode in assembly source listing.

## Trace Log
Name | Short | Type | Description
:----|-------|:-----|:-----------
*nmi-first* | n0 | integer | First NMI to consider for things that are nmi range based. Currently only affects the trace log.
*nmi-last* | n1 | integer | Last NMI to consider for things that are nmi range based. Currently only affects the trace log.
*tracelogoutfile* | tl | output file name | Generated trace log. Nmi range can be controlled using nmi-first and nmi-last. Custom printing can be done using scripting.
*scriptfile* | s | input file name | A squirrel script. See scripting reference in the user guide for entry point functions as well as API specification.

## Annotations
Name | Short | Type | Description
:----|-------|:-----|:-----------
*labelsfile* | l | input file name | A file containing annotations. Custom file format.
*autolabelsfile* | al | input/output file name | A file containing annotations. These are special as it will be regenerated if deleted or if autoannotate is specified.
*autoannotate* | aa | boolean | Auto annotate labels. Automatically generate labels in free space (not used by symbols from regular labelsfile-files) space and save to autolabelsfile. This will also happen if the file specified by autolabelsfile is missing.
*symbolfmaoutfile* | sf | output file name | Generated symbols file in FMA format compatible with bsnes-plus.

## Reports
Name | Short | Type | Description
:----|-------|:-----|:-----------
*reportoutfile* | rp | output file name | Generated assembly report. Companion file to asmoutfile.

## Rewind
Name | Short | Type | Description
:----|-------|:-----|:-----------
*rewindoutfile* | rw | output file name | Generated rewind report in .DOT file format. Use graphviz to generate PDF/PNG report.

Scripting
=========
Some features of snestistics can only be reached from scripts. Currently snestistics only supports scripts written in the scripting language squirrel. Here you can find all functions you can use when scripting.

Trace Log
---------
When the trace log feature is enabled on the command line and a script is given snestistics expects the script to be a squirrel script with the following functions:

~~~~~~
trace_log_init(replay)
    Replay replay: a replay object
    returns: nothing
~~~~~~
This function is used for setup. Breakpoints can be set on the replay objects and global squirrel state can be constructed if the user wants that.

~~~~~~
trace_log_parameter_printer(replay, report)
    Replay replay: a replay object
    ReportWriter report: a report writer object
    returns: nothing
~~~~~~
This function is called whenever the trace log hits a program counter that it has a breakpoint set for. The trace log system itself will print the name of the function and determine indentation, but this is a chance to do additional printing on some functions that are under investigation.

Rewind
------
TODO.

Scripting API
=============

Replay
------
These are the operations that can be performed on an instance of the Replay class.

~~~~~~
replay.set_breakpoint(pc)
    integer pc: the program counter to set a break point at
    returns: nothing
~~~~~~

~~~~~~
replay.set_breakpoint_range(pc_start, pc_end)
    integer pc_start: the first program counter to set a break point at
    integer pc_end: the last program counter to set a break point at
    returns: nothing
~~~~~~

~~~~~~
replay.read_byte(address)
    integer address: 24-bit address specifying where to read a byte (8-bit)
    returns: integer
~~~~~~

~~~~~~
replay.read_word(address)
    integer address: 24-bit address specifying where to read a byte (16-bit)
    returns: integer
~~~~~~

~~~~~~
replay.read_long(address)
    integer address: 24-bit address specifying where to read a byte (24-bit)
    returns: integer
~~~~~~

~~~~~~
replay.pc()
    returns: current program counter
~~~~~~

~~~~~~
replay.a()
    returns: current value of register a (16-bit)
~~~~~~

~~~~~~
replay.al()
    returns: current low byte of register a (8-bit)
~~~~~~

~~~~~~
replay.ah()
    returns: current high byte of register a (8-bit)
~~~~~~

~~~~~~
replay.x()
    returns: current value of register x (16-bit)
~~~~~~

~~~~~~
replay.xl()
    returns: current low byte of register x (8-bit)
~~~~~~

~~~~~~
replay.xh()
    returns: current high byte of register x (8-bit)
~~~~~~

~~~~~~
replay.y()
    returns: current value of register y (16-bit)
~~~~~~

~~~~~~
replay.yl()
    returns: current low byte of register y (8-bit)
~~~~~~

~~~~~~
replay.yh()
    returns: current high byte of register y (8-bit)
~~~~~~

~~~~~~
replay.p()
    returns: current value of status register (16-bit)
~~~~~~

~~~~~~
replay.s()
    returns: current value of stack register (16-bit)
~~~~~~

~~~~~~
replay.dp()
    returns: current value of direct page register (16-bit)
~~~~~~

~~~~~~
replay.db()
    returns: current value of data bank register (8-bit)
~~~~~~

ReportWriter
------------
These are the operations that can be performed on an instance of the ReportWriter class:

~~~~~~
report_writer.print(str)
    str: string to print
    returns: nothing
~~~~~~

Will write the string str to the report at the current indentation level. Adds a newline automatically.

<script>markdeepOptions={tocStyle:'medium'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script>
