---
title: Snestistics User Guide
---
<meta charset="utf-8" emacsmode="-*- markdown -*-">
<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/apidoc.css?">

**Snestistics User Guide**

Introduction
============
In general snestistics wants a ROM-file and a trace-file to do something useful. See command line option on how to give these two snestistics. The in the [first entry](tutorial-1) in the [tutorial series](tutorial) shows how to create a trace file.

Assembly listing
================
If you supply a ROM-file and a trace-file (written by snes9x-snestistics) you can generate an assembly listing of the program. See the command line reference for relevant switches. Then annotations can be be added to beautify the assembly listing.

Annotations
===========
Snestistics uses labels-files to let the user add information about instructions. This has multiple purposes. The first is to let the user annotate and beautify the assembly listing to make it more comprehensible. The second is to guide the predict logic, the auto annotate logic as well guiding the trace log to perform better. In this section we will show some examples. It is allowed to have multiple labels-files. This can help organization of your reverse engineering effort.

## Functions
A function is composed of a range with a starting address and an end address. These are easy to find from the assembly listing. Comments can be added with ; on lines before the function keyword. The line starting with # specifies a *use comment* that is special. It is used as a summary that is written whenever someone references this function (say a jump). That way you get a summary at the site of the jump.
~~~~~~~~~~~~~~
# Important function
; This function seems very important
; It does many things
function 801000 802000 MyFunction
~~~~~~~~~~~~~~

Functions are not allowed to overlap.

## Data
Currently data ranges acts almost like a function. They are, however, allowed to be inside a function range (but not overlap function start/end).
~~~~~~~~~~~~~~
# Big table of data
; Data seems to be compressed
; TODO: needs more investigation!
data 803000 804000 Table4
~~~~~~~~~~~~~~

## Labels
Labels are similar to functions but they do not specify a range. They can be used if there is no logical range to assign to a function. They provide all the features of functions apart from that:
~~~~~~~~~~~~~~
# Important function
; This function seems very important
; It does many things
label 801000 MyFunction
~~~~~~~~~~~~~~

Labels can exist within functions and inside data blocks but they can't start at the same line as a function/data block starts/ends.

## Comments
~~~~~~~~~~~~~~
comment 801000 "Wow this really is an interesting function"
comment 801000 "I should write a book about this line!"
~~~~~~~~~~~~~~

If you want to create multi-line comments the *line* keyword is also useful:
~~~~~~~~~~~~~~
; Comment 1
; Comment 2
line 807000
~~~~~~~~~~~~~~

## Hidden lines
Lines starting with @ are ignored. They are handy when writing notes to yourself that should not be part of the assembly listing, or if you want to put some text at the top of the labels file for people who download it:
~~~~~~~~~~~~~~
@ TODO: Re-organize the labels file
~~~~~~~~~~~~~~

## Hints
WIP.

Command Line Reference
======================
{% include generated-command-line-reference.html %}

Scripting
=========
Some features of snestistics can only be reached from scripts. Currently snestistics only supports scripts written in the scripting language squirrel. Here you can find all functions you can use when scripting.

Trace Log
---------
When the trace log feature is enabled on the command line and a script is given snestistics expects the script to be a squirrel script with the following functions:

~~~~~~
trace_log_init(replay)
    Replay replay: a replay object
    returns: nothing
~~~~~~
This function is used for setup. Breakpoints can be set on the replay objects and global squirrel state can be constructed if the user wants that.

~~~~~~
trace_log_parameter_printer(replay, report)
    Replay replay: a replay object
    ReportWriter report: a report writer object
    returns: nothing
~~~~~~
This function is called whenever the trace log hits a program counter that it has a breakpoint set for. The trace log system itself will print the name of the function and determine indentation, but this is a chance to do additional printing on some functions that are under investigation.

Scripting API Reference
=======================

Replay
------
These are the operations that can be performed on an instance of the Replay class.

~~~~~~
replay.set_breakpoint(pc)
    integer pc: the program counter to set a break point at
    returns: nothing
~~~~~~

~~~~~~
replay.set_breakpoint_range(pc_start, pc_end)
    integer pc_start: the first program counter to set a break point at
    integer pc_end: the last program counter to set a break point at
    returns: nothing
~~~~~~

~~~~~~
replay.read_byte(address)
    integer address: 24-bit address specifying where to read a byte (8-bit)
    returns: integer
~~~~~~

~~~~~~
replay.read_word(address)
    integer address: 24-bit address specifying where to read a byte (16-bit)
    returns: integer
~~~~~~

~~~~~~
replay.read_long(address)
    integer address: 24-bit address specifying where to read a byte (24-bit)
    returns: integer
~~~~~~

~~~~~~
replay.pc()
    returns: current program counter
~~~~~~

~~~~~~
replay.a()
    returns: current value of register a (16-bit)
~~~~~~

~~~~~~
replay.al()
    returns: current low byte of register a (8-bit)
~~~~~~

~~~~~~
replay.ah()
    returns: current high byte of register a (8-bit)
~~~~~~

~~~~~~
replay.x()
    returns: current value of register x (16-bit)
~~~~~~

~~~~~~
replay.xl()
    returns: current low byte of register x (8-bit)
~~~~~~

~~~~~~
replay.xh()
    returns: current high byte of register x (8-bit)
~~~~~~

~~~~~~
replay.y()
    returns: current value of register y (16-bit)
~~~~~~

~~~~~~
replay.yl()
    returns: current low byte of register y (8-bit)
~~~~~~

~~~~~~
replay.yh()
    returns: current high byte of register y (8-bit)
~~~~~~

~~~~~~
replay.p()
    returns: current value of status register (16-bit)
~~~~~~

~~~~~~
replay.s()
    returns: current value of stack register (16-bit)
~~~~~~

~~~~~~
replay.dp()
    returns: current value of direct page register (16-bit)
~~~~~~

~~~~~~
replay.db()
    returns: current value of data bank register (8-bit)
~~~~~~

ReportWriter
------------
These are the operations that can be performed on an instance of the ReportWriter class:

~~~~~~
report_writer.print(str)
    str: string to write in the report
    returns: nothing
~~~~~~

Will write the string str to the report at the current indentation level. Adds a newline automatically.

<script>markdeepOptions={tocStyle:'medium'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script>
