#pragma once

namespace snestistics {

enum class Operation {
	ADC = 0,
	AND = 1,
	ASL = 2,
	BCC = 3,
	BCS = 4,
	BEQ = 5,
	BIT = 6,
	BMI = 7,
	BNE = 8,
	BPL = 9,
	BRA = 10,
	BRK = 11,
	BRL = 12,
	BVC = 13,
	BVS = 14,
	CLC = 15,
	CLD = 16,
	CLI = 17,
	CLV = 18,
	CMP = 19,
	COP = 20,
	CPX = 21,
	CPY = 22,
	DEC = 23,
	DEX = 24,
	DEY = 25,
	EOR = 26,
	INC = 27,
	INX = 28,
	INY = 29,
	JML = 30,
	JMP = 31,
	JSL = 32,
	JSR = 33,
	LDA = 34,
	LDX = 35,
	LDY = 36,
	LSR = 37,
	MVN = 38,
	MVP = 39,
	NOP = 40,
	ORA = 41,
	PEA = 42,
	PEI = 43,
	PER = 44,
	PHA = 45,
	PHB = 46,
	PHD = 47,
	PHK = 48,
	PHP = 49,
	PHX = 50,
	PHY = 51,
	PLA = 52,
	PLB = 53,
	PLD = 54,
	PLP = 55,
	PLX = 56,
	PLY = 57,
	REP = 58,
	ROL = 59,
	ROR = 60,
	RTI = 61,
	RTL = 62,
	RTS = 63,
	SBC = 64,
	SEC = 65,
	SED = 66,
	SEI = 67,
	SEP = 68,
	STA = 69,
	STP = 70,
	STX = 71,
	STY = 72,
	STZ = 73,
	TAX = 74,
	TAY = 75,
	TCD = 76,
	TCS = 77,
	TDC = 78,
	TRB = 79,
	TSB = 80,
	TSC = 81,
	TSX = 82,
	TXA = 83,
	TXS = 84,
	TXY = 85,
	TYA = 86,
	TYX = 87,
	WAI = 88,
	WDM = 89,
	XBA = 90,
	XCE = 91,
};

static const char* const Operation_names[92]={
	"ADC",
	"AND",
	"ASL",
	"BCC",
	"BCS",
	"BEQ",
	"BIT",
	"BMI",
	"BNE",
	"BPL",
	"BRA",
	"BRK",
	"BRL",
	"BVC",
	"BVS",
	"CLC",
	"CLD",
	"CLI",
	"CLV",
	"CMP",
	"COP",
	"CPX",
	"CPY",
	"DEC",
	"DEX",
	"DEY",
	"EOR",
	"INC",
	"INX",
	"INY",
	"JML",
	"JMP",
	"JSL",
	"JSR",
	"LDA",
	"LDX",
	"LDY",
	"LSR",
	"MVN",
	"MVP",
	"NOP",
	"ORA",
	"PEA",
	"PEI",
	"PER",
	"PHA",
	"PHB",
	"PHD",
	"PHK",
	"PHP",
	"PHX",
	"PHY",
	"PLA",
	"PLB",
	"PLD",
	"PLP",
	"PLX",
	"PLY",
	"REP",
	"ROL",
	"ROR",
	"RTI",
	"RTL",
	"RTS",
	"SBC",
	"SEC",
	"SED",
	"SEI",
	"SEP",
	"STA",
	"STP",
	"STX",
	"STY",
	"STZ",
	"TAX",
	"TAY",
	"TCD",
	"TCS",
	"TDC",
	"TRB",
	"TSB",
	"TSC",
	"TSX",
	"TXA",
	"TXS",
	"TXY",
	"TYA",
	"TYX",
	"WAI",
	"WDM",
	"XBA",
	"XCE",
};

enum class InstructionSize {
	INDEX = 0,
	MEMORY = 1,
	SMALL = 2,
	WIDE = 3,
};

static const char* const InstructionSize_names[4]={
	"INDEX",
	"MEMORY",
	"SMALL",
	"WIDE",
};

enum class Operand {
	ABSOLUTE = 0,
	ABSOLUTE_INDEXED_X = 1,
	ABSOLUTE_INDEXED_X_INDIRECT = 2,
	ABSOLUTE_INDEXED_Y = 3,
	ABSOLUTE_INDIRECT = 4,
	ABSOLUTE_INDIRECT_LONG = 5,
	ABSOLUTE_LONG = 6,
	ABSOLUTE_LONG_INDEXED_X = 7,
	ACCUMULATOR = 8,
	BRANCH_16 = 9,
	BRANCH_8 = 10,
	DIRECT_PAGE = 11,
	DIRECT_PAGE_INDEXED_X = 12,
	DIRECT_PAGE_INDEXED_X_INDIRECT = 13,
	DIRECT_PAGE_INDEXED_Y = 14,
	DIRECT_PAGE_INDIRECT = 15,
	DIRECT_PAGE_INDIRECT_INDEXED_Y = 16,
	DIRECT_PAGE_INDIRECT_LONG = 17,
	DIRECT_PAGE_INDIRECT_LONG_INDEXED_Y = 18,
	IMMEDIATE_INDEX = 19,
	IMMEDIATE_MEMORY = 20,
	MANUAL = 21,
	STACK_RELATIVE = 22,
	STACK_RELATIVE_INDIRECT_INDEXED_Y = 23,
};

static const char* const Operand_names[24]={
	"ABSOLUTE",
	"ABSOLUTE_INDEXED_X",
	"ABSOLUTE_INDEXED_X_INDIRECT",
	"ABSOLUTE_INDEXED_Y",
	"ABSOLUTE_INDIRECT",
	"ABSOLUTE_INDIRECT_LONG",
	"ABSOLUTE_LONG",
	"ABSOLUTE_LONG_INDEXED_X",
	"ACCUMULATOR",
	"BRANCH_16",
	"BRANCH_8",
	"DIRECT_PAGE",
	"DIRECT_PAGE_INDEXED_X",
	"DIRECT_PAGE_INDEXED_X_INDIRECT",
	"DIRECT_PAGE_INDEXED_Y",
	"DIRECT_PAGE_INDIRECT",
	"DIRECT_PAGE_INDIRECT_INDEXED_Y",
	"DIRECT_PAGE_INDIRECT_LONG",
	"DIRECT_PAGE_INDIRECT_LONG_INDEXED_Y",
	"IMMEDIATE_INDEX",
	"IMMEDIATE_MEMORY",
	"MANUAL",
	"STACK_RELATIVE",
	"STACK_RELATIVE_INDIRECT_INDEXED_Y",
};

struct OpCode {
	Operation op;
	InstructionSize size;
	Operand mode;
	bool load_operand;
};

extern const char* const mnemonic_names[256]; // as used in an assembler
extern const OpCode op_codes[256];
}
