#include "options.h"

// This file is generated by utilities/command-line-parsing.py

#include "utils.h" // CUSTOM_ASSERT
#include <cstdlib>
#include <cstring> // strcmp
#include <stdexcept> // std::runtime_error

namespace {
	bool parse_bool(const char * const s, bool &error) {
		if ((strcmp(s, "true" )==0) || (strcmp(s, "on" )==0) || (strcmp(s, "1" )==0)) return true;
		if ((strcmp(s, "false")==0) || (strcmp(s, "off")==0) || (strcmp(s, "0" )==0)) return false;
		error = true;
		return true;
	}
	uint32_t parse_uint(const char * const s, bool &error) {
		return atoi(s);
	}

	void syntax() {
		printf("Snestistics Syntax:\n");
		printf(" -romfile (--r)                 ROM file. Currently only LoROM ROMs are allowed\n");
		printf(" -romsize (--rs)                Size of ROM cartridge (without header). A value of 0 means auto-detect (which reads the size from tracefiles)\n");
		printf(" -rommode (--rm)                Type of ROM\n");
		printf(" -tracefile (--t)               Trace file from an emulation session. Multiple allowed for assembly source listing (but not trace log or rewind)\n");
		printf(" -regenerate (--rg)             Regenerate emulation caches. Needs to be run if trace files has been updated\n");
		printf(" -predict (--p)                 Predict can add instructions that was not part of the trace by guessing. This setting specify where snestistics is allowed to guess\n");
		printf(" -nmifirst (--n0)               First NMI to consider for things that are nmi range based. Currently only affects the trace log\n");
		printf(" -nmilast (--n1)                Last NMI to consider for things that are nmi range based. Currently only affects the trace log\n");
		printf(" -tracelogoutfile (--tl)        Generated trace log. Nmi range can be controlled using -nmifirst and -nmilast. Custom printing can be done using scripting\n");
		printf(" -scriptfile (--s)              A squirrel script. See scripting reference in the user guide for entry point functions as well as API specification\n");
		printf(" -labelsfile (--l)              A file containing annotations. Custom file format\n");
		printf(" -autolabelsfile (--al)         A file containing annotations. These are special as it will be regenerated if deleted or if -autoannotate is specified\n");
		printf(" -autoannotate (--aa)           Auto annotate labels. Automatically generate labels in free space (not used by symbols from regular -labelsfile-files) space and save to -autolabelsfile. This will also happen if the file specified by -autolabelsfile is missing\n");
		printf(" -symbolfmaoutfile (--sf)       Generated symbols file in FMA format compatible with bsnes-plus\n");
		printf(" -rewindoutfile (--rw)          Generated rewind report in .DOT file format. Use graphviz to generate PDF/PNG report\n");
		printf(" -reportoutfile (--rp)          Generated assembly report. Companion file to -asmoutfile\n");
		printf(" -asmoutfile (--a)              Generated assembly listing\n");
		printf(" -asmheaderfile (--ah)          Content of this file will be pasted in the Header section of the generated assembly source listing\n");
		printf(" -asmprintpc (--apc)            Print program counter in assembly source listing\n");
		printf(" -asmprintbytes (--ab)          Print opcode bytes in assembly source listing\n");
		printf(" -asmprintregistersizes (--ars) Print registers sizes in assembly source listing\n");
		printf(" -asmprintdb (--adb)            Print data bank in assembly source listing\n");
		printf(" -asmprintdp (--adp)            Print direct page in assembly source listing\n");
		printf(" -asmlowercaseop                Print lower-case opcode in assembly source listing\n");
		printf(" -asmcorrectwla                 Make sure generated source compiled in WLA DX\n");
	}
}

void parse_options(const int argc, const char * const argv[], Options &options) {
	bool error = false;
	bool had_option = false;
	bool need_trace = false;
	bool need_single_trace = false;
	bool need_rom = false;

	for (int k=1; k<argc; k++) {
		if (!had_option && argv[k][0] != '-')
			continue; // When launched from .bat files sometimes the name of the binary is in both argv[0] and argv[1]

		had_option = true;

		const char *const cmd = &argv[k][1];
		const char *const opt = k+1 != argc ? argv[k+1] : "";

		if (strcmp(cmd, "romfile")==0 || strcmp(cmd, "-r")==0) {
			options.rom_file = opt;
			k++;
		} else if (strcmp(cmd, "romsize")==0 || strcmp(cmd, "-rs")==0) {
			options.rom_size = parse_uint(opt, error);
			k++;
		} else if (strcmp(cmd, "rommode")==0 || strcmp(cmd, "-rm")==0) {
			if (strcmp(opt, "trace")==0) options.rom_mode = Options::RM_TRACE;
			if (strcmp(opt, "lorom")==0) options.rom_mode = Options::RM_LOROM;
			if (strcmp(opt, "hirom")==0) options.rom_mode = Options::RM_HIROM;
			k++;
		} else if (strcmp(cmd, "tracefile")==0 || strcmp(cmd, "-t")==0) {
			options.trace_files.push_back(opt);
			need_rom = true;
			k++;
		} else if (strcmp(cmd, "regenerate")==0 || strcmp(cmd, "-rg")==0) {
			options.regenerate = parse_bool(opt, error);
			need_trace = true;
			k++;
		} else if (strcmp(cmd, "predict")==0 || strcmp(cmd, "-p")==0) {
			if (strcmp(opt, "never")==0) options.predict = Options::PRD_NEVER;
			if (strcmp(opt, "functions")==0) options.predict = Options::PRD_FUNCTIONS;
			if (strcmp(opt, "everywhere")==0) options.predict = Options::PRD_EVERYWHERE;
			need_trace = true;
			k++;
		} else if (strcmp(cmd, "nmifirst")==0 || strcmp(cmd, "-n0")==0) {
			options.nmi_first = parse_uint(opt, error);
			k++;
		} else if (strcmp(cmd, "nmilast")==0 || strcmp(cmd, "-n1")==0) {
			options.nmi_last = parse_uint(opt, error);
			k++;
		} else if (strcmp(cmd, "tracelogoutfile")==0 || strcmp(cmd, "-tl")==0) {
			options.trace_log_out_file = opt;
			need_single_trace = true;
			need_trace = true;
			k++;
		} else if (strcmp(cmd, "scriptfile")==0 || strcmp(cmd, "-s")==0) {
			options.script_file = opt;
			k++;
		} else if (strcmp(cmd, "labelsfile")==0 || strcmp(cmd, "-l")==0) {
			options.labels_files.push_back(opt);
			k++;
		} else if (strcmp(cmd, "autolabelsfile")==0 || strcmp(cmd, "-al")==0) {
			options.auto_labels_file = opt;
			k++;
		} else if (strcmp(cmd, "autoannotate")==0 || strcmp(cmd, "-aa")==0) {
			options.auto_annotate = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "symbolfmaoutfile")==0 || strcmp(cmd, "-sf")==0) {
			options.symbol_fma_out_file = opt;
			k++;
		} else if (strcmp(cmd, "rewindoutfile")==0 || strcmp(cmd, "-rw")==0) {
			options.rewind_out_file = opt;
			need_single_trace = true;
			need_trace = true;
			k++;
		} else if (strcmp(cmd, "reportoutfile")==0 || strcmp(cmd, "-rp")==0) {
			options.report_out_file = opt;
			k++;
		} else if (strcmp(cmd, "asmoutfile")==0 || strcmp(cmd, "-a")==0) {
			options.asm_out_file = opt;
			need_trace = true;
			k++;
		} else if (strcmp(cmd, "asmheaderfile")==0 || strcmp(cmd, "-ah")==0) {
			options.asm_header_file = opt;
			k++;
		} else if (strcmp(cmd, "asmprintpc")==0 || strcmp(cmd, "-apc")==0) {
			options.asm_print_pc = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmprintbytes")==0 || strcmp(cmd, "-ab")==0) {
			options.asm_print_bytes = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmprintregistersizes")==0 || strcmp(cmd, "-ars")==0) {
			options.asm_print_register_sizes = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmprintdb")==0 || strcmp(cmd, "-adb")==0) {
			options.asm_print_db = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmprintdp")==0 || strcmp(cmd, "-adp")==0) {
			options.asm_print_dp = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmlowercaseop")==0 || strcmp(cmd, "-")==0) {
			options.asm_lower_case_op = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmcorrectwla")==0 || strcmp(cmd, "-")==0) {
			options.asm_correct_wla = parse_bool(opt, error);
			k++;
		} else {
			printf("Switch '%s' not recognized\n", cmd);
			error = true;
			break;
		}
	}
	CUSTOM_ASSERT(!need_trace        || !options.trace_files.empty());
	CUSTOM_ASSERT(!need_rom          || !options.rom_file.empty());
	CUSTOM_ASSERT(!need_single_trace || options.trace_files.size() == 1);

	if (error) {
		printf("There was an error in the command line.\n");
		syntax();
		exit(1);
	}
}
