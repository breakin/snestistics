#include "options.h"

// This file is generated by utilities/command-line-parsing.py

#include "utils.h" // CUSTOM_ASSERT
#include <cstdlib>
#include <cstring> // strcmp
#include <stdexcept> // std::runtime_error

namespace {
	bool parse_bool(const char * const s, bool &error) {
		if ((strcmp(s, "true" )==0) || (strcmp(s, "on" )==0) || (strcmp(s, "1" )==0)) return true;
		if ((strcmp(s, "false")==0) || (strcmp(s, "off")==0) || (strcmp(s, "0" )==0)) return false;
		error = true;
		return true;
	}
	uint32_t parse_uint(const char * const s, bool &error) {
		return atoi(s);
	}

	void syntax() {
		printf("Snestistics Syntax:\n");
		printf("  snestistics --option1 value --option2 value\n");
		printf("\n");
		printf("Options:\n");
		printf("\n");
		printf(" -romfile (--r) <filename>                      ROM file.\n");
		printf("                                                Currently only LoROM ROMs are supported.\n");
		printf(" -romsize (--rs) <number>                       Size of ROM cartridge (without header).\n");
		printf("                                                0 means auto-detect.\n");
		printf("                                                Default: 0.\n");
		printf(" -tracefile (--t) <filename>                    Trace file from an emulation session.\n");
		printf("                                                Multiple allowed for assembly source listing.\n");
		printf(" -nmifirst (--n0) <number>                      First NMI to consider for trace log.\n");
		printf("                                                Default: 0.\n");
		printf(" -nmilast (--n1) <number>                       Last NMI to consider for trace log.\n");
		printf("                                                Default: 0.\n");
		printf(" -tracelogoutfile (--tl) <filename>             Generate trace log.\n");
		printf("                                                Nmi range can be controlled using -nmifirst and -nmilast.\n");
		printf("                                                Custom printing can be done using scripting.\n");
		printf(" -scriptfile (--s) <filename>                   A squirrel script.\n");
		printf("                                                See user guide for scripting reference.\n");
		printf(" -labelsfile (--l) <filename>                   A file containing annotations.\n");
		printf("                                                Custom file format.\n");
		printf(" -autolabelsfile (--al) <filename>              A file containing annotations.\n");
		printf("                                                It will be regenerated if missing or if -autoannotate is specified.\n");
		printf(" -autoannotate (--aa) <true|false>              A file where automatically generated annotations are stored.\n");
		printf(" -symbolfmaoutfile (--sf) <filename>            Generate symbols file in FMA format compatible with bsnes-plus.\n");
		printf(" -rewindoutfile (--rw) <filename>               Generate rewind report in dot file format.\n");
		printf("                                                Use graphviz to generate PDF/PNG report.\n");
		printf(" -reportoutfile (--rp) <filename>               Generate assembly report.\n");
		printf("                                                Companion file to -asmoutfile.\n");
		printf(" -asmoutfile (--a) <filename>                   Generate assembly listing.\n");
		printf(" -predict (--p) <never|*functions*|everywhere>  This setting specify where snestistics is allowed to predict code.\n");
		printf("                                                This is currently only used for assembly listing.\n");
		printf(" -asmheaderfile (--ah) <filename>               File content will be included in assembly listing.\n");
		printf(" -asmprintpc (--apc) <true|false>               Print program counter in assembly source listing.\n");
		printf(" -asmprintbytes (--ab) <true|false>             Print opcode bytes in assembly source listing.\n");
		printf(" -asmprintregistersizes (--ars) <true|false>    Print registers sizes in assembly source listing.\n");
		printf(" -asmprintdb (--adb) <true|false>               Print data bank in assembly source listing.\n");
		printf(" -asmprintdp (--adp) <true|false>               Print direct page in assembly source listing.\n");
		printf(" -asmlowercaseop <true|false>                   Print lower-case opcode in assembly source listing.\n");
		printf(" -asmcorrectwla <true|false>                    Make sure generated source compiled in WLA DX.\n");
	}
}

void parse_options(const int argc, const char * const argv[], Options &options) {
	bool error = false;
	bool had_option = false;
	bool need_trace = false;
	bool need_single_trace = false;
	bool need_rom = false;

	for (int k=1; k<argc; k++) {
		if (!had_option && argv[k][0] != '-')
			continue; // When launched from .bat files sometimes the name of the binary is in both argv[0] and argv[1]

		had_option = true;

		const char *const cmd = &argv[k][1];
		const char *const opt = k+1 != argc ? argv[k+1] : "";

		if (strcmp(cmd, "romfile")==0 || strcmp(cmd, "-r")==0) {
			options.rom_file = opt;
			k++;
		} else if (strcmp(cmd, "romsize")==0 || strcmp(cmd, "-rs")==0) {
			options.rom_size = parse_uint(opt, error);
			k++;
		} else if (strcmp(cmd, "tracefile")==0 || strcmp(cmd, "-t")==0) {
			options.trace_files.push_back(opt);
			need_rom = true;
			k++;
		} else if (strcmp(cmd, "nmifirst")==0 || strcmp(cmd, "-n0")==0) {
			options.nmi_first = parse_uint(opt, error);
			k++;
		} else if (strcmp(cmd, "nmilast")==0 || strcmp(cmd, "-n1")==0) {
			options.nmi_last = parse_uint(opt, error);
			k++;
		} else if (strcmp(cmd, "tracelogoutfile")==0 || strcmp(cmd, "-tl")==0) {
			options.trace_log_out_file = opt;
			need_single_trace = true;
			need_trace = true;
			k++;
		} else if (strcmp(cmd, "scriptfile")==0 || strcmp(cmd, "-s")==0) {
			options.script_file = opt;
			k++;
		} else if (strcmp(cmd, "labelsfile")==0 || strcmp(cmd, "-l")==0) {
			options.labels_files.push_back(opt);
			k++;
		} else if (strcmp(cmd, "autolabelsfile")==0 || strcmp(cmd, "-al")==0) {
			options.auto_labels_file = opt;
			k++;
		} else if (strcmp(cmd, "autoannotate")==0 || strcmp(cmd, "-aa")==0) {
			options.auto_annotate = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "symbolfmaoutfile")==0 || strcmp(cmd, "-sf")==0) {
			options.symbol_fma_out_file = opt;
			k++;
		} else if (strcmp(cmd, "rewindoutfile")==0 || strcmp(cmd, "-rw")==0) {
			options.rewind_out_file = opt;
			need_single_trace = true;
			need_trace = true;
			k++;
		} else if (strcmp(cmd, "reportoutfile")==0 || strcmp(cmd, "-rp")==0) {
			options.report_out_file = opt;
			k++;
		} else if (strcmp(cmd, "asmoutfile")==0 || strcmp(cmd, "-a")==0) {
			options.asm_out_file = opt;
			need_trace = true;
			k++;
		} else if (strcmp(cmd, "predict")==0 || strcmp(cmd, "-p")==0) {
			if (strcmp(opt, "never")==0) options.predict = Options::PRD_NEVER;
			if (strcmp(opt, "functions")==0) options.predict = Options::PRD_FUNCTIONS;
			if (strcmp(opt, "everywhere")==0) options.predict = Options::PRD_EVERYWHERE;
			need_trace = true;
			k++;
		} else if (strcmp(cmd, "asmheaderfile")==0 || strcmp(cmd, "-ah")==0) {
			options.asm_header_file = opt;
			k++;
		} else if (strcmp(cmd, "asmprintpc")==0 || strcmp(cmd, "-apc")==0) {
			options.asm_print_pc = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmprintbytes")==0 || strcmp(cmd, "-ab")==0) {
			options.asm_print_bytes = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmprintregistersizes")==0 || strcmp(cmd, "-ars")==0) {
			options.asm_print_register_sizes = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmprintdb")==0 || strcmp(cmd, "-adb")==0) {
			options.asm_print_db = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmprintdp")==0 || strcmp(cmd, "-adp")==0) {
			options.asm_print_dp = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmlowercaseop")==0 || strcmp(cmd, "-")==0) {
			options.asm_lower_case_op = parse_bool(opt, error);
			k++;
		} else if (strcmp(cmd, "asmcorrectwla")==0 || strcmp(cmd, "-")==0) {
			options.asm_correct_wla = parse_bool(opt, error);
			k++;
		} else {
			printf("Switch '%s' not recognized\n", cmd);
			error = true;
			break;
		}
	}
	CUSTOM_ASSERT(!need_trace        || !options.trace_files.empty());
	CUSTOM_ASSERT(!need_rom          || !options.rom_file.empty());
	CUSTOM_ASSERT(!need_single_trace || options.trace_files.size() == 1);

	if (error) {
		printf("There was an error in the command line.\n");
		syntax();
		exit(1);
	}
}
